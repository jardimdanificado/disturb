ffi_sig_name = (sig){
  s = sig.trim();
  depth = 0;
  open = -1;
  i = s.size - 1;
  while (i >= 0) {
    ch = s.slice(i, i + 1);
    if (ch == ")") {
      depth++;
    } else if (ch == "(") {
      depth--;
      if (depth == 0) {
        open = i;
        break;
      }
    }
    i--;
  }
  if (open < 0) { return null; }
  head = s.slice(0, open).trim();
  parts = head.split(" ");
  if (parts.size == 0) { return null; }
  return (parts[parts.size - 1].split("!")[0] + "");
};

ffi_bind_all = (path, ...sigs){
  h = ffi.open(path);
  if (h == null) { return null; }
  api = { __lib = h };
  each(sig in sigs) {
    name = ffi_sig_name(sig);
    ptr = ffi.sym(h, name);
    if (ptr == null) { return null; }
    api[name] = ffi.bind(ptr, sig);
  }
  return api;
};

fail = 0;
pair = { a = "i32", b = "i32" };

load_fixture = (path){
  return ffi_bind_all(path,
    "i32 call_cb_i32(void*, i32, i32)",
    "i32 fold_cb_i32(void*, i32, i32)",
    "f64 call_cb_f64(void*, f64, f64)",
    "i32 call_cb_pair_sum(void*, i32, i32)"
  );
};

lib = load_fixture("./tests/ffi/libffi_view_struct.so");
if (lib == null) { lib = load_fixture("./tests/ffi/libffi_view_struct.dylib"); }
if (lib == null) { lib = load_fixture("./tests/ffi/libffi_view_struct.dll"); }
if (lib == null) {
  println(1);
  return 0;
}

cb_add = ffi.callback("i32 cb(i32, i32)", (a, b){ return a + b; });
if (lib.call_cb_i32(cb_add, 9, 4) != 13) { fail++; }

cb_mul_add = ffi.callback("i32 fold(i32, i32)", (acc, x){ return acc + (x * 2); });
if (lib.fold_cb_i32(cb_mul_add, 1, 4) != 21) { fail++; }

cb_f = ffi.callback("f64 cbf(f64, f64)", (a, b){ return a + b + 0.25; });
if (lib.call_cb_f64(cb_f, 1.5, 2.5) != 4.25) { fail++; }

cb_pair = ffi.callback("struct(pair) cbp(struct(pair))", (p){
  p.a = p.a + 1;
  p.b = p.b + 2;
  return p;
});
if (lib.call_cb_pair_sum(cb_pair, 3, 4) != 10) { fail++; }

cb_abi = ffi.callback("abi(default) i32 cbabi(i32, i32)", (a, b){ return a - b; });
if (lib.call_cb_i32(cb_abi, 9, 4) != 5) { fail++; }

println(fail);
